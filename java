1.集合类型
  collection包括list(有序可重复)和set(无序不可重复)。
  list类型有ArraryList和LinkList,其中ArraryList根据索引进行排序，底层是基于动态数组，有利
  快速访问，LinkList底层基于双向链表实现的。set类型有hashset和treeset,hashset底层是哈希散列表，允许null值，要求放入的对象必须实现hashcode,
  treeset底层是基于二叉树实现，可实现元素排序，但不能放入null值。
  map包括hashtable、hashmap和treemap.
  hashtable继承自dictionary类(已被废弃)，不支持null key和null value,线程安全；hashmap继承自AbstractMap类，只支持一个null key，线程不安全(
  jdk1.5后可用线程安全的currentHashMap代替)；treeMap继承自sortedMap,线程不安全，底层基于红黑树实现，通过实现comparable或comparetor接口排序。


2.JVM内存模型
  1）程序计数器：
        一块较小的内存空间，作用是当前线程所执行的字节码的行号指示器。
  2)java虚拟机栈
        线程私有，生命周期与线程相同。描述的是java方法执行的内存模型。每个方法所执行的时候都会创建一个栈帧。用于存储局部变量表，操作栈、动态链接、
        方法出口等信息。每个方法被调用过程就对应着一个虚拟机从入栈到出栈的过程。
        该区域规定两种异常情况：
        A.StackOverflowError异常：如果线程请求的栈深度大于虚拟机所允许的深度
        B.OutOfMemoryError异常：如果虚拟机栈可以动态扩展，但无法申请到足够的内存时抛出此异常
  3)本地方法栈
        与java虚拟机栈类似，为虚拟机使用到的Native方法服务。也会抛出StackOverflowError异常和OutOfMemoryError异常
  4)java堆
        虚拟机管理的最大一块内存，也是所有线程共享的一块内存区域。作用是存放对象实例。几乎所有对象实例都在这里分配内存，也是GC管理的主要区域。
        如果堆中没有完成实例分配，并且堆也无法扩展时，将会抛出OutofMemoryError异常。
  5)方法区
        各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量和即时编译器编译后的代码等数据。GC当方法区的内存回收目标主要是针对
        常量池的回收和对类型的卸载。当方法区无法满足为内存分配需求时将抛出OutofMemoryError异常。
        
3.GC回收机制
  GC回收的对象：
        1）该类所有的实例都被回收,即java堆不存在该类的任何实例
        2）加载该类的classLoader已被回收
        3）该类对应的java.lang.class对象没有在任何地方被引用，无法在任何地方通过反射方法访问该类的方法。
  GC回收算法：
        1）标记-清除法(会产生不连续的内存碎片)
        2）复制算法（对新生代对象清理有效，对象存活率高，频繁操作时效率低）
        3）标记-整理算法（将所有的存活对象移动到一端，并对不存活对象进行处理，因此其不会产生内存碎片）
        4)分代收集算法（目前主流，根据对象存活周期，分为新生代和老年代，新生代对象存活率低，就采用复制算法；老年代存活率高，
        就用标记清除算法或者标记整理算法）
